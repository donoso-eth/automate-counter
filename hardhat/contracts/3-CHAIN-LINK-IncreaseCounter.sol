//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "hardhat/console.sol";
import {IncreaseCounter} from "./IncreaseCounter.sol";
// KeeperCompatible.sol imports the functions from both ./KeeperBase.sol and
// ./interfaces/KeeperCompatibleInterface.sol
import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";

interface ILinkToken {
  function transferAndCall(
    address receiver,
    uint256 amount,
    bytes calldata data
  ) external returns (bool success);

  function balanceOf(address user) external view returns (uint256);

  function approve(address spender, uint256 amount) external;

  function transfer(address _to, uint256 _amount) external;
}

interface IKeepersRegistry {
  function getRegistrar() external view returns (address);

  function withdrawOwnerFunds() external;

  function cancelUpkeep(uint256 id) external;
}

interface IKeepersRegistrar {
  function cancel(bytes32 hash) external;
}

contract ChainLinkIncreaseContract is
  KeeperCompatibleInterface,
  IncreaseCounter
{
  address public REGISTRY_ADDRESS = 0x409CF388DaB66275dA3e44005D182c12EeAa12A0; //0x6179B349067af80D0c171f43E6d767E4A00775Cd; //mumbai testnet

  address public ERC677_LINK_ADDRESS =
    0x01BE23585060835E02B77ef475b0Cc51aA1e0709; //
  //  0x326C977E6efc84E512bB9C30f76E30c160eD06FB; //mumbai testnet (LINK addresses: https://docs.chain.link/docs/link-token-contracts/)

  bytes4 private constant REGISTER_FUNC_SELECTOR =
    bytes4(
      keccak256(
        "register(string,bytes,address,uint32,address,bytes,uint96,uint8)"
      )
    );

  bytes32 public taskId;

  uint256 public minFundingAmount = 5000000000000000000; //5 LINK
  uint8 public SOURCE = 110;

  ILinkToken ERC677Link = ILinkToken(ERC677_LINK_ADDRESS);

  constructor(uint256 updateInterval) IncreaseCounter(updateInterval) {
    console.log("Deploying a CHAINLINK Automatation Task");
  }

  //Note: make sure to fund this contract with LINK before calling createUpkeep
  function createUpkeep() public {
    require(
      taskIdByUser[msg.sender] == bytes32(0),
      "Upkeep Already registered"
    );
    address registarAddress = IKeepersRegistry(REGISTRY_ADDRESS).getRegistrar();
    uint96 amount = uint96(minFundingAmount);

    bytes memory data = abi.encodeWithSelector(
      REGISTER_FUNC_SELECTOR,
      "IC-1",
      hex"",
      address(this),
      100000,
      address(this),
      hex"",
      amount,
      SOURCE
    );
    bytes32 hash = keccak256(
      abi.encode(address(this), 100000, address(this), hex"")
    );
    taskId = hash;
    ERC677Link.transferAndCall(registarAddress, minFundingAmount, data);
  }

  function cancelUpkeep() external {
    require(taskId != bytes32(0), "Upkeep Notregistered");
    address registarAddress = IKeepersRegistry(REGISTRY_ADDRESS).getRegistrar();
    bytes32 hash = taskId;

    IKeepersRegistrar(registarAddress).cancel(hash);
    taskId = bytes32(0);
  }

  function cancelUpkeepByHash(bytes32 hash) external {
    require(taskId != bytes32(0), "Upkeep Notregistered");
    address registarAddress = IKeepersRegistry(REGISTRY_ADDRESS).getRegistrar();

    IKeepersRegistrar(registarAddress).cancel(hash);
    taskId = bytes32(0);
  }

  function cancelUpkeepById(uint256 id) external {
    IKeepersRegistry(REGISTRY_ADDRESS).cancelUpkeep(id);
  }

  function withdraw() external {
    IKeepersRegistry(REGISTRY_ADDRESS).withdrawOwnerFunds();
    uint256 amount = ERC677Link.balanceOf(address(this));
    ERC677Link.transfer(msg.sender, amount);
  }

  function checkUpkeep(
    bytes calldata /* checkData */
  )
    external
    view
    override
    returns (
      bool upkeepNeeded,
      bytes memory /* performData */
    )
  {
    upkeepNeeded = (block.timestamp - lastTimestamp) > interval;
    // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
  }

  function performUpkeep(
    bytes calldata /* performData */
  ) external override {
    //We highly recommend revalidating the upkeep in the performUpkeep function
    if ((block.timestamp - lastTimestamp) > interval) {
      increaseCounter();
    }
    // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
  }

  receive() external payable {}
}
